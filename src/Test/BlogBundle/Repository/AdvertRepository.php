<?php

namespace Test\BlogBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\queryBuilder;

/**
 * AdvertRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AdvertRepository extends EntityRepository
{
	public function myFindAll(){
	   /*
		* $queryBuilder = $this->createQueryBuilder('a');
		* $query = $queryBuilder->getQuery();
		* $result =$query->getResult();
		* return $result;
		*/

		//ou 

		return $this
			->createQueryBuilder('a')
			->getQuery()
			->getResult();

	   /*
		* dans un controlleur : 
		* $listAdvert = $repository->myFindAll();
		*/	

	}

	public function myFindOne($id){
		$qb = $this->createQueryBuilder('a');
		$qb
			->where('a.id = :id') // je défini un parametre dans la requête
			->setParameter('id', $id); // je lui attribue une valeur

		return $qb->getQuery->getResult;	
	}

	public function findByAuthorAndDate($author, $year){

		$qb = $this->createQueryBuilder('a');
		$qb
			->where('a.author = :author')
			->setParameter('author', $author)
			->andWhere('a.date < :year')
			->setParameter('year', $year)
			->orderBy('a.date', 'DESC');

		return $qb
			->getQuery()
			->getResult();	

	}

	public function whereCurrentYear(QueryBuider $qb){

		$qb
			->andWhere('a.date BETWEEN :start AND :end')
			->setParameter('start', new \Datetime(date('Y').'-01-01')) // date entre le 01/01
			->setParameter('end', new \Datetime(date('Y').'-12-31')) // et le 31/12
	}

   /*
	* Dans une autre requete : 
	*
	* public function myFind(){
  	*	$qb = $this->createQueryBuilder('a');
	*	On peut ajouter ce qu'on veut avant
  	*	$qb
    *		->where('a.author = :author')
    *		->setParameter('author', 'Marine');
	*
	*	On applique notre condition sur le QueryBuilder
  	*	$this->whereCurrentYear($qb);
	*
  	*	// On peut ajouter ce qu'on veut après
  	*	$qb->orderBy('a.date', 'DESC');
	*
  	*	return $qb
    *		->getQuery()
    *		->getResult();
	* }
	*
	*/

	//jointure

	public function getAdvertWithApplications(){
		$qb = $this
			->createQueryBuilder('a')
			->leftJoin('a.application', 'app')
			->addSelect('app');

		return $qb
			->getQuery()
			->getResult();
	}

   /*
	* Attention : on ne peut faire une jointure 
	* que si l'entité du FROM possède un attribut vers l'entité à joindre ! 
	* Cela veut dire que soit l'entité du FROM est l'entité propriétaire de la relation, 
	* soit la relation est bidirectionnelle.
	*/

	public function getAdvertWithCategories(array $categoryNames){

    	$qb = $this->createQueryBuilder('a');
    // On fait une jointure avec l'entité Category avec pour alias « c »
	    $qb
	      ->innerJoin('a.categories', 'c')
	      ->addSelect('c');

    // Puis on filtre sur le nom des catégories à l'aide d'un IN
    	$qb->where($qb->expr()->in('c.name', $categoryNames));
    // La syntaxe du IN et d'autres expressions se trouve dans la documentation Doctrine

    // Enfin, on retourne le résultat qui est un tableau
	    return $qb
	      ->getQuery()
	      ->getResult();
  	}

  	public function getApplicationsWithAdvert($limit){

    $qb = $this->createQueryBuilder('a');

    // On fait une jointure avec l'entité Advert avec pour alias « adv »
    $qb
      ->innerJoin('a.advert', 'adv')
      ->addSelect('adv');

    // Puis on ne retourne que $limit résultats
    $qb->setMaxResults($limit);

    // Enfin, on retourne le résultat
    return $qb
      ->getQuery()
      ->getResult()
      ;
  }


}
